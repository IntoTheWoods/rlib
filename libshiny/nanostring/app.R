library("shiny")
library("ggplot2")

# Define UI for data upload app ----
ui <- fluidPage(

  # App title ----
  titlePanel("Nanostring QC"),

  # Sidebar layout with input and output definitions ----
  sidebarLayout(

    # Sidebar panel for inputs ----
    sidebarPanel(

      # Input: Select a file ----
      fileInput("file1", "Choose ZIP File",
                multiple = FALSE,
                accept = c("text/csv",
                         "text/comma-separated-values,text/plain",
                         ".zip",".ZIP","application/zip")),

      # Horizontal line ----
      tags$hr()
#             downloadButton('download',label="Download plot as png")



    ),

    # Main panel for displaying outputs ----
    mainPanel(

      # Output: Data file ----
      plotOutput("contents", height = "800px")

    )

  )
)

# Define server logic to read selected file ----
server <- function(input, output) {

  output$contents <- renderPlot({

    # input$file1 will be NULL initially. After the user selects
    # and uploads a file, head of that data file by default,
    # or all rows if selected, will be shown.

    req(input$file1)

    # when reading semicolon separated files,
    # having a comma separator causes `read.csv` to error

    file.copy(input$file1$datapath, "/data/opt/rlib/libshiny/nanostring/test.zip", overwrite=TRUE)

workingDirectory           = "/data/opt/rlib/libshiny/nanostring"
select_housekeeping_genes  = F
replicate_use              = 'patient'
confidence_level           = 0.9973
num_clusters               = 10
flThreshold                = 0.95
min_FovRatio               = 0.85
max_BindingDensity         = 2.2
max_pos.norm.factor        = 3
min_pos.norm.factor        = 0.3
max_MaxNegative            = 6
subset_data                = T
floor_data                 = F
renormalize                = F
exclude_technical_controls = F
include_3d_pca             = F
##############################################################
control_treatments         = c("control")  #### CHECK THIS
##############################################################
## approximate eSAP genes
#key_genes                  = c("gene_symbol")
normalization_genes        = unlist(list(c(""),c("PTPRC_all"),c("CD3E","CD3D"))[[1]])   ## normalization_genes setting of 1 below is housekeeping gene default
pca_type                   = c("expression","fold change")[1]
fdr_method                 = c("none","BH","bonferroni","fdr")[1]
renorm_code_count          = c("none","geo.mean")[1]  ## 1 is default in Jason's code
renorm_sample_content      = c("housekeeping.geo.mean", "none")[1] ## 1 is default in Jason's code
renorm_other_norm          = c("none","vsn")[1]

## set working directory
setwd(workingDirectory)

## remove files generated by r-script-nano so it doesn't give an error
unlink("./ZIP", recursive=T)
unlink("./RCC", recursive=T)
unlink("./QC", recursive=T)
unlink("./Batch", recursive=T)


library(libbase)
library(libsql)
library(libplot)
library(RSQLite)
library(ggplot2)
library(reshape2)
library(ggpmisc)
library(grid)
library(dplyr)
library(ggrepel)
library(NanoStringNorm)
library(scales)   ## scale_fill_gradient2(limits=c(0,1), oob=squish) in heatmaps

## if plyr is previously loaded, it breaks the dplyr summarize
if ("package:plyr" %in% search()) {
  #  detach("package:cellrangerRkit")
  #  detach("package:Rmisc")
  detach("package:plyr")
}


source("./scripts/workflow.qc_and_batch_process.R")

data_raw      = read.table("./Batch/Expression.Raw.txt",sep="\t", header=T, quote="\"", stringsAsFactors = F, comment.char = "")
data_rawlog2  = read.table("./Batch/Expression.RawLog2.txt",sep="\t", header=T, quote="\"", stringsAsFactors = F, comment.char = "")
data_floored  = read.table("./Batch/Expression.Floored.txt",sep="\t", header=T, quote="\"", stringsAsFactors = F, comment.char = "")
data          = read.table("./Batch/Expression.Normalized.txt",sep="\t", header=T, quote="\"", stringsAsFactors = F, comment.char = "")
meta          = read.table("./Batch/Nanostring.QCData.txt",sep="\t", header=T, quote="\"", stringsAsFactors = F, comment.char = "")


##############################################################################
##
## flag QC metrics
##
##############################################################################

## remove duplicate columns
meta = meta[,!duplicated(colnames(meta))]


## add additional columns to use for QC purposes
meta$FovRatio = meta$FovCounted/meta$FovCount
meta$Amount.ng = meta$Adjusted_Input_Required
meta$sample_name = meta$ID.Sample
#meta$sample_name = meta$Subject_ID

## because Jason's script doesn't calculate positive norm factor, use sample content as proxy
meta$pos.norm.factor = meta$sampleContent.norm.factor

## determine whether individual samples pass QC metrics and flag them appropriately
meta$pass_qc = ifelse(meta$FovRatio           < min_FovRatio          |
                        meta$BindingDensity   > max_BindingDensity  |
                        meta$pos.norm.factor  > max_pos.norm.factor   |
                        meta$pos.norm.factor  < min_pos.norm.factor   |
                        meta$MaxNegative      > max_MaxNegative       , FALSE, TRUE)

source("./scripts/workflow.qc_plot.R")

#      return(renderPlot({print(plot.FovRatio)}))
      return(qc_plot(meta))

  })

  output$download <- downloadHandler(
    filename <- "shinytestplot.png",
    content <- function(file){ ## file = NULL --> file
      png(file) # filename --> file
      qc_plot(meta)
      dev.off()
    }
  )


}

# Create Shiny app ----
shinyApp(ui, server)

